#!/usr/bin/env python3

#
# Converts Objective-C interface generated by sdp to a collection of
# python protocol definitions.
#
# Sample usage:
#
# sdef /Applications/App.app > App.sdef
# sdp -fh --basename App App.sdef
# ./objc2py.py App.h

# when  translate apple script to python
# it may helpful


import sys
import struct
import re
import platform

from itertools import chain

from clang.cindex import TranslationUnit
from clang.cindex import CursorKind
from clang.cindex import Config
from clang.cindex import TypeKind

import string


Config.set_library_path("/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib")

# See https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html
parameter_keywords = ['let', 'var', 'inout']
general_keywords = ['associatedtype', 'class', 'deinit', 'enum', 'extension',
                    'fileprivate', 'func', 'import', 'init', 'inout', 'internal', 'let', 'open',
                    'operator', 'private', 'protocol', 'public', 'static', 'struct', 'subscript',
                    'typealias', 'var', 'break', 'case', 'continue', 'default', 'defer', 'do', 'else',
                    'fallthrough', 'for', 'guard', 'if', 'in', 'repeat', 'return', 'switch', 'where',
                    'while', 'as', 'Any', 'catch', 'false', 'is', 'nil', 'rethrows', 'super', 'self',
                    'Self', 'throw', 'throws', 'true', 'try', '_']

type_dict = {
    'BOOL': 'bool',
    'double': 'float',
    'long': 'int',
    'int': 'int',
    'id': 'any',
    'SEL': 'any',
    'NSArray': 'list',
    'NSData': 'any',
    'NSDate': 'date',
    'NSDictionary': 'dict',
    'NSInteger': 'int',
    'NSString': 'str',
    'NSURL': 'str',
}

object_kinds = [TypeKind.OBJCID, TypeKind.OBJCOBJECTPOINTER]

base_protocols = """
# base_protocols = """


generic_pattern = re.compile(r'(.*)<(.*)>.*')
all_caps_re = re.compile('([A-Z]+)($)')
single_cap_re = re.compile('([A-Z])([^A-Z]+.*)')
multiple_caps_re = re.compile('([A-Z]+)([A-Z]([^0-9]+.*))')
caps_to_digit_re = re.compile('([A-Z]+)([0-9]+.*)')


def is_readonly(objc_type_encoding):
    if 'R' in objc_type_encoding:
        return True
    return False

def safe_name(name, keywords=parameter_keywords):
    return '`{}`'.format(name) if name in keywords else name


def arg_name(name, position=0):
    if position > 0:
        if name.endswith('_'):
            stripped_name = name.rstrip('_')
            return '{} {}'.format(safe_name(stripped_name), name)
        else:
            return safe_name(name)
    else:
        return safe_name(name)


def type_for_spelling(spelling):
    obj_type_string = spelling.strip().split(" ")[0]
    return type_dict.get(obj_type_string, obj_type_string)


def type_for_type(objc_type, as_arg=False):
    generic_match = generic_pattern.match(objc_type.spelling)
    if generic_match:
        #
        # This is rudimentary support for lightweight generic declarations
        # of NSArray, NSDictionary, and NSSet objects
        #
        base_type = generic_match.groups()[0]
        opening, closing = {'NSSet': ('Set<', '>')}.get(base_type, ('[', ']'))
        generic_parts = generic_match.groups()[1].split(",")
        mapped_parts = [type_for_spelling(generic_part) for generic_part in generic_parts]
        result_type = opening + " : ".join(mapped_parts) + closing
    else:
        result_type = type_for_spelling(objc_type.spelling)

    if as_arg and objc_type.kind in object_kinds:
        result_type += '!'
    return result_type


def name_from_path(path):
    last_part = path.split("/")[-1]
    return last_part.split('.')[0]


def strip_prefix(prefix, a_string):
    if a_string.startswith(prefix):
        a_string = a_string[len(prefix):]
    return a_string


def enum_case(prefix, enum_case):
    stripped_case = strip_prefix(prefix, enum_case)
    converted_enum_case = stripped_case
    for regex in (all_caps_re, single_cap_re, caps_to_digit_re, multiple_caps_re):
        match = regex.match(stripped_case)
        if match:
            groups = match.groups()
            converted_enum_case = groups[0].lower() + groups[1]
            break
    return safe_name(converted_enum_case, keywords=general_keywords)


def cursor_super_entity(cursor):
    tokens = [token.spelling for token in cursor.get_tokens()]
    if tokens[3] == ":" and len(tokens) > 4:
        return tokens[4]


class SBHeaderProcessor(object):
    py_file = None

    def __init__(self, file_path):
        self.file_path = file_path
        fid = open(file_path)
        self.lines = fid.readlines()
        fid.close()
        self.app_name = name_from_path(file_path)
        self.category_dict = {}

    def line_comment(self, cursor):
        line = self.lines[cursor.location.line - 1]
        parts = line.strip().split('//')
        return ' #{}'.format(parts[1]) if len(parts) == 2 else ''

    def emit_enums(self, cursors):
        for cursor in cursors:
            self.emit_line('\n# MARK: {}'.format(cursor.spelling))
            # self.emit_line('@objc public enum {} : AEKeyword {{'.format(cursor.spelling))
            self.emit_line('class {}(Enum):'.format(cursor.spelling))
            for decl in [child for child in cursor.get_children() if child.kind == CursorKind.ENUM_CONSTANT_DECL]:
                # self.emit_line('   {}'.format(self.line_comment(cursor)))
                self.emit_line('    {} = {} # {} '.format(
                    enum_case(cursor.spelling, decl.spelling),
                    hex(decl.enum_value),
                    repr(struct.pack('!i', decl.enum_value))))
            # self.emit_line('}\n')


    def emit_line(self, line=''):
        self.py_file.write(line + '\n')

    def emit_property(self, cursor):
        py_type = type_for_type(cursor.type)
        name = safe_name(cursor.spelling, keywords=general_keywords)
        self.emit_line('    def {}(self) -> {}: {}'.format(name, py_type,
                                              self.line_comment(cursor)))
        self.emit_line('        pass')
        
        # not readonly
        if is_readonly(cursor.objc_type_encoding) == False:
            self.emit_line('    def set{}_(self, {}): '.format(string.capwords(name), py_type
                                                             ))
            self.emit_line('        pass')

    def emit_function(self, cursor):
        try:
            
            # 函数名称
            func_name=cursor.spelling.replace(':','_')
        
            parameter_cursors = [child for child in cursor.get_children() if child.kind == CursorKind.PARM_DECL]
            parameters = ['{}: {}'.format(arg_name(child.spelling, position=parameter_cursors.index(child)), type_for_type(child.type, as_arg=True))
                          for child in parameter_cursors]
        
            return_type = [child.type for child in cursor.get_children() if child.kind != CursorKind.PARM_DECL]
            if return_type:
                return_string = ' -> {}'.format(type_for_type(return_type[0]))
            else:
                return_string = ''
                
            self_str='self'
            if len(parameters)>0:
                self_str+=' ,'

            parameters_str=", ".join(parameters)
            parameters_str=parameters_str.replace('!','')

            space_str='    '
            
            if len(func_name)>40 :
                self.emit_line('   {}'.format(self.line_comment(cursor)))
                self.emit_line('    def {}(  '.format(
                    func_name))
                self.emit_line('{}{}{}){}:  '.format(space_str*3,
                    self_str,parameters_str , return_string))
            else:    
                self.emit_line('    def {}({}{}){}:  {}'.format(
                    func_name, self_str,parameters_str , return_string, self.line_comment(cursor)))
        
            self.emit_line('        pass')

        except ValueError as e:
            self.emit_line(f'# {func_name} ValueError {e}')
            # pass
        
        
    def emit_protocol(self, cursor):
        protocol_name = cursor.spelling
        self.emit_line('\n# MARK: {}'.format(protocol_name))
        cursor_is_interface = cursor.kind == CursorKind.OBJC_INTERFACE_DECL
        super_entity = cursor_super_entity(cursor)
        if cursor_is_interface:
            implemented_protocols = [child.spelling for child in cursor.get_children() if child.kind == CursorKind.OBJC_PROTOCOL_REF]
            protocols = ", ".join(implemented_protocols)
        else:
            protocols = super_entity
        extends = '{}'.format(protocols) if protocols else ''

        if cursor_is_interface:
            extension_class = super_entity 
            extends=  extends +' ' +extension_class
        
        self.emit_line('class {}({}) :'.format(protocol_name, extends))
        
        property_getters = [child.spelling
                            for child in chain(cursor.get_children(), self.category_dict.get(cursor.spelling, []))
                            if child.kind == CursorKind.OBJC_PROPERTY_DECL]
        function_list = property_getters
        emitted_properties = []
        implemented_protocols = []
        for child in chain(cursor.get_children(), self.category_dict.get(cursor.spelling, [])):
            if child.kind == CursorKind.OBJC_PROPERTY_DECL and child.spelling not in emitted_properties:
                self.emit_property(child)
                emitted_properties.append(child.spelling)
            elif child.kind == CursorKind.OBJC_INSTANCE_METHOD_DECL and child.spelling not in function_list:
                self.emit_function(child)
                function_list.append(child.spelling)
            elif child.kind == CursorKind.OBJC_PROTOCOL_REF:
                self.emit_line('# implemented_protocols')
                implemented_protocols.append(child.spelling)
        

    def gather_categories(self, categories):
        for category in categories:
            children = [child for child in category.get_children() if child.kind != CursorKind.OBJC_CLASS_REF]
            class_item = [child for child in category.get_children() if child.kind == CursorKind.OBJC_CLASS_REF][0]
            key = class_item.spelling
            category_items = self.category_dict.get(key, [])
            self.category_dict[key] = category_items + children

    def emit_python(self):
        cmakeArgs = ["-ObjC"]
        macOsVersion = float('.'.join(platform.mac_ver()[0].split('.')[:2])) # poor man's version fetch
        if macOsVersion >= 10.13:
            cmakeArgs.append("-I/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/")
            cmakeArgs.append("-F/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/")

        translation_unit = TranslationUnit.from_source(self.file_path, args=cmakeArgs)
        self.py_file = open('{}.py'.format(self.app_name), 'w')
        
        self.emit_line('import ScriptingBridge')
        self.emit_line('from enum import Enum')
        
        cursor = translation_unit.cursor
        local_children = [child for child in cursor.get_children()
                          if child.location.file and child.location.file.name == self.file_path]


        for child in [child for child in local_children if child.kind == CursorKind.OBJC_PROTOCOL_DECL]:
            self.emit_protocol(child)

        categories = [child for child in local_children if child.kind == CursorKind.OBJC_CATEGORY_DECL]
        self.gather_categories(categories)
        
        for child in [child for child in local_children if child.kind == CursorKind.OBJC_INTERFACE_DECL]:
            self.emit_protocol(child)


        enums = [child for child in local_children if child.kind == CursorKind.ENUM_DECL]
        self.emit_enums(enums)
            
        self.py_file.close()


def main(file_path):
    header_processor = SBHeaderProcessor(file_path)
    header_processor.emit_python()


if __name__ == '__main__':
    main(sys.argv[1])
